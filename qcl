#!/usr/bin/env bash

# NOTES:
# - Use VNC or QXL/SPICE so qemu can run as another user

function show_help {
cat <<EndOfHelp
usage: ${0} [- options...]

System options:

      --nokvm|--nohvf       Disable KVM/HVF accelleration
      --cpu <cpu>           Specify the CPU to emulate
      --cores               Specify number of cores (default = [cores+1]/2)
      --efi <bits>          Boot using <bits>-bit UEFI instead of BIOS
      --win2k               Enable Win2K hack (solves disk full bug, slows IDE)
      --legacy              Use legacy hardware*
      --ram <MiB>           Specify RAM available to VM
      --sound               Enable sound
      --term <term-bin>     Launch QEMU in <term-bin> in background
      --mouse               Use USB mouse instead of tablet device
      --gpu <card>          Specify the GPU_CARD device to use

    *i440FX + PIIX + Cirrus VGA + AMD PCNet NIC + no VirtIO

Drive options:

      --drive <file>:<floppy|ide|scsi|ahci|virtio>

Network options:

      --forward <port:port> Forward host's <port> to guest's <port>
      --pcnet               Use an AMD PCNet NIC instead of VirtIO
      --ne2k                Use an NE2000-compatible NIC instead of VirtIO
      --rtl8139             Use a Realtek 8139 NIC instead of VirtIO

Display options:

      The default is to start a VNC host and launch a VNC viewer.

      --gtk             Use a GTK window (QEMU default)
      --qxl <port>      Use QXL/SPICE instead of VNC
      --daemon          Don't launch SPICE/vncviewer directly
      --xport           Specify X11 listening port number

Utilties:

      -h|--help         This help text.

EndOfHelp
}

FLOPS=0
PATAS=0
SATAS=0
SCSIS=0
VIRTS=0

function add_if_none {
  case "${S_DRIVES}" in
    *${1}*) return;;
         *) S_DRIVES="${S_DRIVES} -device ${1}"
  esac
}

function add_drive {
  DISC_IMG=${1%%:*}
  INTERFACE=${1##*:}

  case ${DISC_IMG##*.} in
    dsk|DSK) DVC_TYPE='fd'; DVC_FRMT='raw';   MEDIATYPE='floppy';;
      fd|FD) DVC_TYPE='fd'; DVC_FRMT='raw';   MEDIATYPE='floppy';;
    iso|ISO) DVC_TYPE="cd"; DVC_FRMT='raw';   MEDIATYPE='cdrom';;
    img|IMG) DVC_TYPE='hd'; DVC_FRMT='raw';   MEDIATYPE='disk';;
       luks) DVC_TYPE='hd'; DVC_FRMT='luks';  MEDIATYPE='disk';;
       qcow) DVC_TYPE='hd'; DVC_FRMT='guess'; MEDIATYPE='disk';;
        qed) DVC_TYPE='hd'; DVC_FRMT='qed';   MEDIATYPE='disk';;
        vdi) DVC_TYPE='hd'; DVC_FRMT='vdi';   MEDIATYPE='disk';;
       vhdx) DVC_TYPE='hd'; DVC_FRMT='vhdx';  MEDIATYPE='disk';;
       vmdk) DVC_TYPE='hd'; DVC_FRMT='vmdk';  MEDIATYPE='disk';;
        vpc) DVC_TYPE='hd'; DVC_FRMT='vpc';   MEDIATYPE='disk';;
          *) DVC_TYPE='hd'; DVC_FRMT='raw';   MEDIATYPE='disk';;
  esac

  case ${INTERFACE} in
    floppy)
      S_DRIVES="${S_DRIVES} -drive id=floppy${FLOPS},media=${MEDIATYPE},file='${DISC_IMG}',cache=none,if=floppy,bus=$((FLOPS/2)),unit=$((FLOPS%2))"
      (( FLOPS++ ));;
    ide)
      S_DRIVES="${S_DRIVES} -drive id=pata${PATAS},media=${MEDIATYPE},file='${DISC_IMG}',cache=none,if=ide,bus=$((PATAS/2)),unit=$((PATAS%2))"
      (( PATAS++ ));;
    ahci)
      [ "${MACHINE}" == 'type=pc' ] && echo 'Cannot use ahci on legacy hardware -- only floppy, ide, and scsi' && exit 1
      [ "${SATAS}" -eq 0 ] && S_DRIVES="${S_DRIVES} -device ahci,id=ahci"
      S_DRIVES="${S_DRIVES} -device ide-${DVC_TYPE},bus=ahci.${SATAS},drive=sata${SATAS} -drive id=sata${SATAS},media=${MEDIATYPE},file='${DISC_IMG}',cache=none,if=none"
      (( SATAS++ ));;
    scsi)
      [ "${SCSIS}" -eq 0 ] && S_DRIVES="${S_DRIVES} -device virtio-scsi-pci,id=scsi0"
      S_DRIVES="${S_DRIVES} -device scsi-${DVC_TYPE},bus=scsi0.0,drive=scsi${SCSIS} -drive id=scsi${SCSIS},media=${MEDIATYPE},file='${DISC_IMG}',cache=none,if=none,bus=0,unit=${SCSIS}"
      (( SCSIS++ ));;
    virtio)
      [ "${MACHINE}" == 'type=pc' ] && echo 'Cannot use virtio on legacy hardware -- only floppy, ide, and scsi' && exit 1
      S_DRIVES="${S_DRIVES} -drive id=vd${VIRTS},media=${MEDIATYPE},file='${DISC_IMG}',cache=none,if=virtio"
      (( VIRTS++ ));;
  esac
  [ "${DVC_FRMT}" = "guess" ] || S_DRIVES="${S_DRIVES},format=${DVC_FRMT}"
}

USEACCEL=true
BASE='-nodefaults -parallel none -serial none'
MACHINE='type=q35'
FIRMWARE='BIOS'

#CPU
VIRT_CPU="host"
VIRTCORS=$((($(getconf _NPROCESSORS_ONLN)+1)/2))

#RAM (default if not specified)
for MEMORIES in /sys/devices/system/memory/memory*; do
  if [[ $(< "${MEMORIES}/online") == 1 ]]; then
    ((TOTALRAM+=0x$(cat /sys/devices/system/memory/block_size_bytes)))
  fi
done
POWEROF2="$(awk "BEGIN {print int(log(TOTALRAM/3)/log(2))}")"
RAM_SIZE="$((2**POWEROF2))"

# DISPLAY
DSPLYPRT=50
VDISPLAY=vnc
V_LAUNCH=true

# QXL OPTIONS
QXL_VSPD='-device virtio-serial-pci'
QXL_SPRT='-device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0'
QXL_CHAR='-chardev spicevmc,id=spicechannel0,name=vdagent'
QXLDSPLY="spice-app -spice port=60${DSPLYPRT},disable-ticketing ${QXL_VSPD} ${QXL_SPRT} ${QXL_CHAR}"

# DEVICES
VBALLOON='virtio-balloon-pci'
POINTING='virtio-tablet-pci'
NET_CARD='virtio-net-pci'
SND_CARD=''
GPU_CARD='VGA'

while [ ${#} -gt 0 ]; do
  case "${1}" in
      --cores) VIRTCORS="${2}"            ; shift 2;;
        --cpu) VIRT_CPU="${2}"            ; shift 2;;
     --daemon) V_LAUNCH=false             ; shift 1;;
      --drive) add_drive "${2}"           ; shift 2;;
        --efi) FIRMWARE="UEFI${2}"        ; shift 2;;
    --forward) PORT_FWD="${PORT_FWD},hostfwd=tcp::$(echo "${2}" | cut -d: -f1)-:$(echo "${2}" | cut -d: -f2)"; shift 2;;
        --gtk) VDISPLAY='gtk'             ; shift 1;;
        --gpu) GPU_CARD="${2}"            ; shift 2;;
    -h|--help) show_help                  ; exit 0;;
     --initrd) BOOTIRFS="${2}"            ; shift 2;;
     --kernel) BOOTKRNL="${2}"            ; shift 2;;
     --legacy) POINTING=''; VBALLOON=''; NET_CARD='pcnet'; MACHINE='type=pc'; GPU_CARD='cirrus-vga'; VIRT_CPU="pentium3"; BASE="${BASE} -device piix4-usb-uhci"; shift 1;;
      --mouse) POINTING='usb-mouse'       ; shift 1;;
       --ne2k) NET_CARD='ne2k_pci'        ; shift 1;;
      --nohvf) USEACCEL=false             ; shift 1;;
      --nokvm) USEACCEL=false             ; shift 1;;
        --ram) RAM_SIZE="${2}"            ; shift 2;;
      --pcnet) NET_CARD='pcnet'           ; shift 1;;
    --rtl8139) NET_CARD='rtl8139'         ; shift 1;;
        --qxl) VDISPLAY="${QXLDSPLY}"; GPU_CARD='qxl-vga'; shift 2;;
      --sound) SND_CARD='hda-output'      ; shift 1;;
       --term) TERMINAL="${2}"            ; shift 2;;
      --win2k) W2K_HACK='-win2k-hack'     ; shift 1;;
      --xport) DSPLYPRT="${OPTARG}"       ; shift 2;;
            *) echo "Unkonw argument ${1}"; show_help >&2; exit 1;;
  esac
done
shift $((OPTIND-1))

[ -n "${PKEXEC_UID}" ] && SUDO_USER=$(getent passwd "${PKEXEC_UID}" | cut -d: -f1)
[ -z "${SUDO_USER}" ] && echo "Must use sudo or pkexec to run as root." && exit 1

if [ "${FIRMWARE:0:4}" = "UEFI" ]; then
  printf '%s' 'Finding UEFI firmware...'

  # Try to use locate, it's faster

  if command -v plocate > /dev/null; then
    FRMWRFIL="$(plocate "/usr/*${FIRMWARE: -2}/OVMF_CODE.fd")"
  elif command -v mlocate > /dev/null; then
    FRMWRFIL="$(mlocate "/usr/*${FIRMWARE: -2}/OVMF_CODE.fd")"
  elif command -v locate > /dev/null; then
    FRMWRFIL="$(locate "/usr/*${FIRMWARE: -2}/OVMF_CODE.fd")"
  fi

  # Maybe the system doesn't have a locate?

  if [ -z "${FRMWRFIL}" ]; then
    FRMWRFIL="$(find /usr -type f -wholename '/usr/*${FIRMWARE: -2}/OVMF_CODE.fd')"
  fi

  case "${FRMWRFIL}" in
    *OVMF_CODE.fd) UEFI_OPT="-bios ${FRMWRFIL}"; echo "${FRMWRFIL}" ;;
    *) echo 'OVMF_CODE.fd not found' && exit 1 ;;
  esac
fi

for DEVICE in "${GPU_CARD}" "${POINTING}" "${SND_CARD}" "${VBALLOON}"; do
  [ -n "${DEVICE}" ] && DEVICES="${DEVICES} -device ${DEVICE}"
done


if [ -n "${BOOTKRNL}" ] && [ -n "${BOOTIRFS}" ]; then
  BOOTPARM="-kernel ${BOOTKRNL} -initrd ${BOOTIRFS}"
else
  BOOTPARM="-boot menu=on"
fi

case "$(uname)" in
  Linux)
    ${USEACCEL} && KVMACCEL='-enable-kvm' && MACHINE="${MACHINE},accel=kvm"
    VNCMD="vncviewer :${DSPLYPRT}"
    ;;
  Darwin)
    ${USEACCEL} && MACHINE="${MACHINE},accel=hvf"
    VNCMD="open vnc://localhost:59${DSPLYPRT}"
    ;;
esac

lscpu | grep -q topoext && VIRT_CPU="${VIRT_CPU},topoext"

if [ "$(lscpu | grep 'Thread(s) per core' | sed 's/.*: *//g')" = "2" ]; then
  [ "$((VIRTCORS % 2))" = "0" ] && VTHREADS=2 || VTHREADS=1
else
  VTHREADS=1
fi

VMCORES="$((VIRTCORS / VTHREADS))"

if ${V_LAUNCH}; then
  case "${VDISPLAY}" in
    *vnc*)
      VDISPLAY="egl-headless -vnc :${DSPLYPRT}"
      sh -c "sleep 1; su -c DISPLAY=\"${DISPLAY} ${VNCMD}\" - ${SUDO_USER}" > /dev/null 2>&1 & ;;
#   *spice*)
#     command -v spicy > /dev/null 2>&1 && CMMND="spicy -h localhost -p 60${XPORT}"
#     command -v remote-viewer > /dev/null 2>&1 && CMMND="remote-viewer spice://localhost:60${XPORT}"
#     sh -c "sleep 1; su -c 'DISPLAY=${DISPLAY} ${CMMND} > /dev/null 2>&1' - ${SUDO_USER}" & ;;
  esac
fi

TEMPFILE="$(mktemp)"

printf '\n>>> USE send_key TO SEND KEY COMBOS TO VM THAT THE HOST GRABS
>>> USE system_powerdown TO SEND ACPI POWER BUTTON SIGNAL TO VM
>>> USE quit TO TELL QEMU TO STOP IMMEDIATELY
>>> PRESS CTRL+C TO FORCE-QUIT QEMU\n\n' > "${TEMPFILE}"

QEMU_CMD="qemu-system-x86_64 -runas qemu ${KVMACCEL} ${UEFI_OPT} -m ${RAM_SIZE} \
  -machine ${MACHINE} ${BASE} ${W2K_HACK} -cpu ${VIRT_CPU} \
  -smp cores=${VMCORES},threads=${VTHREADS} \
  -monitor stdio -display ${VDISPLAY} \
  -nic user,model=${NET_CARD}${PORT_FWD} \
  ${DEVICES} ${S_DRIVES} ${BOOTPARM}"


if [ -n "${TERMINAL}" ]; then
  set -x
  ${TERMINAL} -e "${QEMU_CMD}" &
  set +x
  sleep 2
else
  [ -t 1 ] && cat "${TEMPFILE}"
  rm "${TEMPFILE}"
  eval "set -x; ${QEMU_CMD}"
fi
