#!/usr/bin/env bash

# NOTES:
# - Use VNC or QXL/SPICE so qemu can run as another user

function show_help {
cat <<EndOfHelp
usage: ${0} [- options...]

System options:

      --nokvm|--nohvf       Disable KVM/HVF accelleration
      --cpu <cpu>           Specify the CPU to emulate
      --cores               Specify number of cores (default = [cores+1]/2)
      --efi <bits>          Boot using <bits>-bit UEFI instead of BIOS
      --win2k               Enable Win2K hack (solves disk full bug, slows IDE)
      --legacy              Use legacy hardware*
      --ram <MiB>           Specify RAM available to VM
      --sound               Enable sound
      --term <term-bin>     Launch QEMU in <term-bin> in background

    *i440FX + PIIX + Cirrus VGA + AMD PCNet NIC + no VirtIO

Drive options:

  If <interface> is not specified qcl will guess based extension and machine type

      --drive <file>:<interface>
            <interface> is one of floppy, ide, scsi, ahci, or virtio

Pointing device options:

      --mouse <qemu-pointer>

         <qemu-pointer> can be anything QEMU accepts, plus "PS/2"
         Common pointers relevant to QCL are:

            ps/2              The standard PS/2 QEMU normally presents the guest
            usb-mouse         Standard USB mouse
            usb-tablet        Standard USB tablet device
            usb-wacom-tablet  QEMU PenPartner Tablet
            vmmouse           ISA bus VM mouse

        Additionally, there are VirtIO devices that can connect to either the
        PCI bus (for guests that cannot use complete VirtIO) or the virtio-bus
        (for full VirtIO utilization.)

           virtio-mouse-pci    virtio-mouse-device
           virtio-tablet-pci   virtio-tablet-device

GPU options

      --gpu <qemu-gpu>

         <qemu-gpu> can be anything QEMU accepts.
         Common GPUs relevant to QCL are:

            cirrus-vga      Cirrus Logic GD-5446
            VGA             Standard VESA VGA device
            vmware          VMWare SVGA device

Network options:

      --forward <port:port> Forward host's <port> to guest's <port>
      --pcnet               Use an AMD PCNet NIC instead of VirtIO
      --ne2k                Use an NE2000-compatible NIC instead of VirtIO
      --rtl8139             Use a Realtek 8139 NIC instead of VirtIO

Display options:

      The default is to start a VNC host and launch a VNC viewer.

      --gtk             Use a GTK window (QEMU default)
      --qxl <port>      Use QXL/SPICE instead of VNC
      --daemon          Don't launch SPICE/vncviewer directly
      --xport           Specify X11 listening port number

Utilties:

      -h|--help         This help text.

EndOfHelp
}

FLOPS=0
PATAS=0
SATAS=0
SCSIS=0
VIRTS=0

function add_if_none {
  case "${S_DRIVES}" in
    *${1}*) return;;
         *) S_DRIVES="${S_DRIVES} -device ${1}"
  esac
}

function add_drive {
  DISC_IMG=${1%%:*}
  INTERFACE=${1##*:}

  case ${DISC_IMG##*.} in
    dsk|DSK) DVC_TYPE='fd'; DVC_FRMT='raw';   MEDIATYPE='floppy';;
      fd|FD) DVC_TYPE='fd'; DVC_FRMT='raw';   MEDIATYPE='floppy';;
    iso|ISO) DVC_TYPE="cd"; DVC_FRMT='raw';   MEDIATYPE='cdrom';;
    img|IMG) DVC_TYPE='hd'; DVC_FRMT='raw';   MEDIATYPE='disk';;
       luks) DVC_TYPE='hd'; DVC_FRMT='luks';  MEDIATYPE='disk';;
       qcow) DVC_TYPE='hd'; DVC_FRMT='guess'; MEDIATYPE='disk';;
        qed) DVC_TYPE='hd'; DVC_FRMT='qed';   MEDIATYPE='disk';;
        vdi) DVC_TYPE='hd'; DVC_FRMT='vdi';   MEDIATYPE='disk';;
       vhdx) DVC_TYPE='hd'; DVC_FRMT='vhdx';  MEDIATYPE='disk';;
       vmdk) DVC_TYPE='hd'; DVC_FRMT='vmdk';  MEDIATYPE='disk';;
        vpc) DVC_TYPE='hd'; DVC_FRMT='vpc';   MEDIATYPE='disk';;
          *) DVC_TYPE='hd'; DVC_FRMT='raw';   MEDIATYPE='disk';;
  esac

  if [ "${INTERFACE}" == "${DISC_IMG}" ]; then
    printf 'Interface not specified for %s - ' "${DISC_IMG}"
    if [ "${MEDIATYPE}" == 'floppy' ]; then
      INTERFACE='floppy'
    elif [ -n "${VBALLON}" ]; then
      INTERFACE='virtio'
    elif [[ "${MACHINE}" =~ q35 ]]; then
      INTERFACE='ahci'
    elif [[ "${MACHINE}" =~ pc ]]; then
      INTERFACE='ide'
    fi
    printf 'guessed %s\n' "${INTERFACE}"
  fi

  case ${INTERFACE} in
    floppy)
      S_DRIVES="${S_DRIVES} -drive id=floppy${FLOPS},media=${MEDIATYPE},file='${DISC_IMG}',cache=none,if=floppy,bus=$((FLOPS/2)),unit=$((FLOPS%2))"
      (( FLOPS++ ));;
    ide)
      S_DRIVES="${S_DRIVES} -drive id=pata${PATAS},media=${MEDIATYPE},file='${DISC_IMG}',cache=none,if=ide,bus=$((PATAS/2)),unit=$((PATAS%2))"
      (( PATAS++ ));;
    ahci)
      [ "${MACHINE}" == 'type=pc' ] && echo 'Cannot use ahci on legacy hardware -- only floppy, ide, and scsi' && exit 1
      [ "${SATAS}" -eq 0 ] && S_DRIVES="${S_DRIVES} -device ahci,id=ahci"
      S_DRIVES="${S_DRIVES} -device ide-${DVC_TYPE},bus=ahci.${SATAS},drive=sata${SATAS} -drive id=sata${SATAS},media=${MEDIATYPE},file='${DISC_IMG}',cache=none,if=none"
      (( SATAS++ ));;
    scsi)
      [ "${SCSIS}" -eq 0 ] && S_DRIVES="${S_DRIVES} -device ${SCSICARD},id=scsi0"
      S_DRIVES="${S_DRIVES} -device scsi-${DVC_TYPE},bus=scsi0.0,drive=scsi${SCSIS} -drive id=scsi${SCSIS},media=${MEDIATYPE},file='${DISC_IMG}',cache=none,if=none,bus=0,unit=${SCSIS}"
      (( SCSIS++ ));;
    virtio)
      [ "${MACHINE}" == 'type=pc' ] && echo 'Cannot use virtio on legacy hardware -- only floppy, ide, and scsi' && exit 1
      S_DRIVES="${S_DRIVES} -drive id=vd${VIRTS},media=${MEDIATYPE},file='${DISC_IMG}',cache=none,if=virtio"
      (( VIRTS++ ));;
  esac
  [ "${DVC_FRMT}" = "guess" ] || S_DRIVES="${S_DRIVES},format=${DVC_FRMT}"
}

function set_vga_resolution {
  [ "${GPU_CARD:0:3}" != "VGA" ] && return
  if [ -z "${1}" ]; then
    SERCHSTR='Display.*primary.*\n(\s+[0-9]+x[0-9]+.*\n)+'
    PDISPRES=$(xrandr | grep -Pzo "${SERCHSTR}" | grep -a '\*' | grep -o '[0-9]\+x[0-9]\+')
    MXHRZNTL="$(( "${PDISPRES%x*}" - 64 ))"
    MXVERTCL="$(( "${PDISPRES#*x}" - 64 ))"
  else
     MXHRZNTL="${1%x*}"
     MXVERTCL="${1#*x}"
  fi

  for DISP_RES in 1920x1080 1680x1050 1600x1200 1280x1024 1440x900 \
                  1280x960 1360x768 1280x800 1280x720 1024x768 800x600 640x480; do
    HORZ_RES="${DISP_RES%x*}"
    VERT_RES="${DISP_RES#*x}"
    [ $((HORZ_RES)) -gt "${MXHRZNTL}" ] || [ $((VERT_RES)) -gt "${MXVERTCL}" ] && continue
    GPU_CARD="VGA,edid=on,xmax=${HORZ_RES},ymax=${VERT_RES}"
    break
  done
}

USEACCEL='true'
BASE='-nodefaults -parallel none -serial none'
MACHINE='type=q35'
FIRMWARE='BIOS'
ENABLESC='false'
MAXDSIZE=''

#CPU
VIRT_CPU="host"
VIRTCORS=$((($(getconf _NPROCESSORS_ONLN)+2)/3))

#RAM (default if not specified)
for MEMORIES in /sys/devices/system/memory/memory*; do
  if [[ $(< "${MEMORIES}/online") == 1 ]]; then
    ((TOTALRAM+=0x$(cat /sys/devices/system/memory/block_size_bytes)))
  fi
done
POWEROF2="$(awk "BEGIN {print int(log(${TOTALRAM}/3)/log(2))}")"
RAM_SIZE="$((2**POWEROF2/1024**2))"

# DISPLAY
DSPLYPRT=50
VDISPLAY=vnc
V_LAUNCH=true

# QXL OPTIONS
QXL_VSPD='-device virtio-serial-pci'
QXL_SPRT='-device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0'
QXL_CHAR='-chardev spicevmc,id=spicechannel0,name=vdagent'
QXLDSPLY="spice-app -spice port=60${DSPLYPRT},disable-ticketing ${QXL_VSPD} ${QXL_SPRT} ${QXL_CHAR}"

# DEVICES
VBALLOON='virtio-balloon-pci'
POINTING='virtio-tablet-pci'
NET_CARD='virtio-net-pci'
SCSICARD='virtio-scsi-pci'
SND_CARD='hda-output'
GPU_CARD='VGA'

while [ ${#} -gt 0 ]; do
  case "${1}" in
      --cores) VIRTCORS="${2}"            ; shift 2;;
        --cpu) VIRT_CPU="${2}"            ; shift 2;;
     --daemon) V_LAUNCH=false             ; shift 1;;
      --drive) add_drive "${2}"           ; shift 2;;
        --efi) FIRMWARE="UEFI${2}"        ; shift 2;;
    --forward) PORT_FWD="${PORT_FWD},hostfwd=tcp::$(echo "${2}" | cut -d: -f1)-:$(echo "${2}" | cut -d: -f2)"; shift 2;;
        --gpu) GPU_CARD="${2}"            ; shift 2;;
        --gtk) VDISPLAY='gtk'             ; shift 1;;
    -h|--help) show_help                  ; exit 0;;
     --initrd) BOOTIRFS="${2}"            ; shift 2;;
     --kernel) BOOTKRNL="${2}"            ; shift 2;;
     --legacy) POINTING=''; VBALLOON=''; NET_CARD='pcnet'; MACHINE='type=pc'; GPU_CARD='cirrus-vga'; VIRT_CPU="pentium3"; BASE="${BASE} -device piix4-usb-uhci"; shift 1;;
     --maxres) MAXDSIZE="${2}"            ; shift 2;;
      --mouse) POINTING="${2}"            ; shift 2;;
       --ne2k) NET_CARD='ne2k_pci'        ; shift 1;;
      --nohvf) USEACCEL=false             ; shift 1;;
      --nokvm) USEACCEL=false             ; shift 1;;
        --ram) RAM_SIZE="${2}"            ; shift 2;;
      --pcnet) NET_CARD='pcnet'           ; shift 1;;
    --rtl8139) NET_CARD='rtl8139'         ; shift 1;;
        --qxl) VDISPLAY="${QXLDSPLY}"; GPU_CARD='qxl-vga'; shift 2;;
      --sound) ENABLESC='true'            ; shift 1;;
       --term) TERMINAL="${2}"            ; shift 2;;
      --win2k) W2K_HACK='-win2k-hack'     ; shift 1;;
      --xport) DSPLYPRT="${OPTARG}"       ; shift 2;;
            *) echo "Unkonw argument ${1}"; show_help >&2; exit 1;;
  esac
done
shift $((OPTIND-1))

[ -n "${PKEXEC_UID}" ] && SUDO_USER=$(getent passwd "${PKEXEC_UID}" | cut -d: -f1)
[ -z "${SUDO_USER}" ] && echo "Must use sudo or pkexec to run as root." && exit 1

if [ "${FIRMWARE:0:4}" = "UEFI" ]; then
  printf '%s' 'Finding UEFI firmware...'

  # Try to use locate, it's faster

  if command -v plocate > /dev/null; then
    FRMWRFIL="$(plocate "/usr/*${FIRMWARE: -2}/OVMF_CODE.fd")"
  elif command -v mlocate > /dev/null; then
    FRMWRFIL="$(mlocate "/usr/*${FIRMWARE: -2}/OVMF_CODE.fd")"
  elif command -v locate > /dev/null; then
    FRMWRFIL="$(locate "/usr/*${FIRMWARE: -2}/OVMF_CODE.fd")"
  fi

  # Maybe the system doesn't have a locate?

  if [ -z "${FRMWRFIL}" ]; then
    FRMWRFIL="$(find /usr -type f -wholename '/usr/*${FIRMWARE: -2}/OVMF_CODE.fd')"
  fi

  case "${FRMWRFIL}" in
    *OVMF_CODE.fd) UEFI_OPT="-bios ${FRMWRFIL}"; echo "${FRMWRFIL}" ;;
    *) echo 'OVMF_CODE.fd not found' && exit 1 ;;
  esac
fi

[ "${GPU_CARD}" == "VGA" ] && set_vga_resolution "${MAXDSIZE}"

for DEVICE in "${GPU_CARD}" "${POINTING}" "${VBALLOON}"; do
  [ -n "${DEVICE}" ] && DEVICES="${DEVICES} -device ${DEVICE}"
done

${ENABLESC} && DEVICES="${DEVICES} -device ${SND_CARD}"

if [ -n "${BOOTKRNL}" ] && [ -n "${BOOTIRFS}" ]; then
  BOOTPARM="-kernel ${BOOTKRNL} -initrd ${BOOTIRFS}"
else
  BOOTPARM="-boot menu=on"
fi

case "$(uname)" in
  Linux)
    ${USEACCEL} && KVMACCEL='-enable-kvm' && MACHINE="${MACHINE},accel=kvm"
    VNCMD="vncviewer :${DSPLYPRT}"
    ;;
  Darwin)
    ${USEACCEL} && MACHINE="${MACHINE},accel=hvf"
    VNCMD="open vnc://localhost:59${DSPLYPRT}"
    ;;
esac

lscpu | grep -q topoext && VIRT_CPU="${VIRT_CPU},topoext"

if [ "$(lscpu | grep 'Thread(s) per core' | sed 's/.*: *//g')" = "2" ]; then
  [ "$((VIRTCORS % 2))" = "0" ] && VTHREADS=2 || VTHREADS=1
else
  VTHREADS=1
fi

VMCORES="$((VIRTCORS / VTHREADS))"

if ${V_LAUNCH}; then
  case "${VDISPLAY}" in
    *vnc*)
      VDISPLAY="egl-headless -vnc :${DSPLYPRT}"
      sh -c "sleep 1; su -c DISPLAY=\"${DISPLAY} ${VNCMD}\" - ${SUDO_USER}" > /dev/null 2>&1 & ;;
#   *spice*)
#     command -v spicy > /dev/null 2>&1 && CMMND="spicy -h localhost -p 60${XPORT}"
#     command -v remote-viewer > /dev/null 2>&1 && CMMND="remote-viewer spice://localhost:60${XPORT}"
#     sh -c "sleep 1; su -c 'DISPLAY=${DISPLAY} ${CMMND} > /dev/null 2>&1' - ${SUDO_USER}" & ;;
  esac
fi

TEMPFILE="$(mktemp)"

printf '\n>>> USE send_key TO SEND KEY COMBOS TO VM THAT THE HOST GRABS
>>> USE system_powerdown TO SEND ACPI POWER BUTTON SIGNAL TO VM
>>> USE quit TO TELL QEMU TO STOP IMMEDIATELY
>>> PRESS CTRL+C TO FORCE-QUIT QEMU\n\n' > "${TEMPFILE}"

if [ "${NET_CARD}" == 'pcnet' ] || [[ "${NET_CARD}" =~ 'ne2k' ]] || [ -z "${NET_CARD}" ]; then
  if [ "${VIRT_CPU}" == '486' ] || [[ "${VIRT_CPU}" =~ 'pentium' ]]; then
    if [ "${SND_CARD}" == 'sb16' ] || [ -z "${SND_CARD}" ]; then
      if [[ ! "${POINTING}" =~ 'tablet' ]]; then
        printf '>>> FOR WINDOWS 9X, âš PLUG & PLAY BIOS = PCI BUS\n\n' >> "${TEMPFILE}"
      fi
    fi
  fi
fi

QEMU_CMD="qemu-system-x86_64 -runas qemu ${KVMACCEL} ${UEFI_OPT} -m ${RAM_SIZE} \
  -machine ${MACHINE} ${BASE} ${W2K_HACK} -cpu ${VIRT_CPU} \
  -smp cores=${VMCORES},threads=${VTHREADS} \
  -monitor stdio -display ${VDISPLAY} \
  -nic user,model=${NET_CARD}${PORT_FWD} \
  ${DEVICES} ${S_DRIVES} ${BOOTPARM}"


if [ -n "${TERMINAL}" ]; then
  set -x
  ${TERMINAL} -e "${QEMU_CMD}" &
  set +x
  sleep 2
else
  [ -t 1 ] && cat "${TEMPFILE}"
  rm "${TEMPFILE}"
  eval "set -x; ${QEMU_CMD}"
fi
