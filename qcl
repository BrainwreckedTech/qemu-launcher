#!/usr/bin/env sh

# NOTES:
# - Use VNC or QXL/SPICE so qemu can run as another user
# - Must use nomodeset with QXL or DMs may crash on user logout or shutdown

# Letter usage -- parens = available
# abcdef(g)hi(j)klmn(o)pqrstuvwx(y)(z)

show_help() {
cat <<EndOfHelp
usage: ${0} [- options...]

System options:

      -c                Specify number of cores (default = [cores+1]/2)
      -e                Boot using UEFI instead of BIOS
      -i                Use IDE disks instead of default VIRTIO
      -m <MiB size>     Specify RAM available to VM
      -k                Enable Win2K hack (solves disk full bug, slows IDE)
      -u                Use USB mouse instead of tablet device
      -t <term-bin>     Launch QEMU in <term-bin> in background

Image options:

      -a </path/to/img> Floppy drive disk image
      -b </path/to/iso> Bootable ISO (will boot this instead of primary drive)
      -d </path/to/iso> Seconday ISO (no boot -- for drivers, etc.)
      -p </path/to/img> Primary drive disk image (bootable drive)
      -s </path/to/img> Secondary drive disk image (no boot)
      -v </path/to/img> Secondary drive disk image, VIRTIO forced
                          (Used when you can't use VirtIO to install Windows)

Network options:

      -f <port:port>    Forward host's <port> to guest's <port>
      -n                Use AMD PCNet instead of VirtIO

Viewer options:

      The default is to launch vncviewer

      -q                Use QXL/SPICE instead of VNC
      -w                Don't launch SPICE/vncviewer directly
      -x                Specify X11 listening port number

Utilties:

      -h              This help text.

EndOfHelp
}

NFSMT=/mnt/nfs
BASE='-nodefaults -parallel none -serial none'
MACHN='type=q35'
MOUSE=tablet
XDISP=50
VIDEO='virtio-gpu'
DSPLY="vnc=localhost:${XDISP}"
CROOT=false
FRMTP=false
IFACE=virtio
NTCRD=virtio-net-pci
VLNCH=true
VCORS=$(( $(( $(getconf _NPROCESSORS_ONLN) + 1)) / 2 ))
FRMWR=BIOS

while getopts "a:b:c:d:ef:ghikl:m:np:qrs:t:uv:wx:" opt; do
  case "${opt}" in
    a) FDIMG="${OPTARG}"   ;;
    b) BTISO="${OPTARG}"   ;;
    c) VCORS="${OPTARG}"   ;;
    d) DRISO="${OPTARG}"   ;;
    e) FRMWR="UEFI"        ;;
#   f) FRMTO="${OPTARG}"   ; FRMTP=true ;;
    f) PRTFW="${PRTFW},hostfwd=tcp::$(echo "${OPTARG}" | cut -d: -f1)-:$(echo "${OPTARG}" | cut -d: -f2)" ;;
    h) show_help; exit 0   ;;
    i) IFACE=ide           ;;
    k) W2KHK="-win2k-hack" ;;
#   l) LSPTD="${OPTARG}"   ;;
    m) RAMSZ="${OPTARG}"   ;;
#   n) PRTFW="${PRTFW},hostfwd=tcp::$(echo "${OPTARG}" | cut -d: -f1)-:$(echo "${OPTARG}" | cut -d: -f2)" ;;
    n) NTCRD=pcnet         ;;
    p) PRIDR="${OPTARG}"   ;;
    q) VIDEO="qxl-vga; DSPLY="spice-app -spice port=60${XDISP},disable-ticketing";;
#   r) CROOT=true          ;;
    s) SCNDR="${OPTARG}"   ;;
    t) TRMNL="${OPTARG}"   ;;
    u) MOUSE="mouse"       ;;
    v) VIODR="${OPTARG}"   ;;
    w) VLNCH=false         ;;
    x) XDISP="${OPTARG}"   ; VIDEO="std -nographic -vnc :${XDISP}" ;;
    '?') show_help >&2 && exit 1;;
  esac
done

shift $((OPTIND-1))

[ -n "${PKEXEC_UID}" ] && SUDO_USER=$(getent passwd "${PKEXEC_UID}" | cut -d: -f1)
[ -z "${SUDO_USER}" ] && echo "Must use sudo or pkexec to run as root." && exit 1

#if ${CROOT}; then
#  LOOPD="$(sudo losetup -fP --show "${PRIDR}")"
#  partprobe # makes sure the kernel gets partition info from losetup
#  PTLST="$(lsblk -lno NAME,FSTYPE | grep "$(echo "${LOOPD}" | cut -b 6-)" | grep 'btrfs\|ext\|jfs\|reiser\|xfs' | cut -d\  -f1 | sed ':a;N;$!ba;s/\n/ /g')"
#  mkdir -p /mnt/crl
#  for CURPT in ${PTLST}; do
#    fsck -faMT "/dev/${CURPT}"
#    mount -v "/dev/${CURPT}" /mnt/crl
#    if [ -f /mnt/crl/etc/fstab ]; then
#      break
#    else
#      umount /mnt/crl
#    fi
#  done
#  mkdir -p "/mnt/crl/${NFSMT}"
#  mount -v --bind "${NFSMT}" "/mnt/crl/${NFSMT}"
#  if command -v arch-chroot > /dev/null 2>&1; then
#    arch-chroot /mnt/crl
#  else
#    mount -t proc proc /mnt/crl/proc
#    mount --rbind /sys /mnt/crl/sys
#    mount --rbind /dev /mnt/crl/dev
#    mount --rbind /run /mnt/crl/run
#    chroot /mnt/crl /bin/sh
#    for BNDMNT in proc sys dev run; do
#      eval umount -l "/mnt/crl/${BNDMNT}"
#    done
#  fi
#  umount -l "/mnt/crl/${NFSMT}"
#  umount -l /mnt/crl
#  losetup -d "${LOOPD}"
#  exit 0
#fi

#if [ -n "${LSPTD}" ]; then
#  parted "${LSPTD}" unit GB print |
#    grep '^[0123456789 ]' |
#    grep -v 'ext[234]\|ntfs\|btrfs\|xfs\|fat32\|reiserfs' |
#    sed 's/^ //g' |
#    sed 's/  */ /g' |
#    cut -d\  -f1,4- |
#    sed 's/\([[:digit:]]\) \([[:digit:]]\)/\1\t\2/g' |
#    sed 's/GB /GB\t/g' |
#    sed "s/^/$(echo "${LSPTD}" | cut -b 6-)/g"
#  exit 0
#fi

#if ${FRMTP}; then
#  if [ -b "${PRIDR}" ]; then
#    dd if=/dev/zero of="${PRIDR}" bs=1M status=progress
#  else
#    if [ "$(echo "${PRIDR}" | cut -b 1-4)" = "/dev" ]; then
#      echo "Block device ${FRMTP} does not exist.  Not creating."
#    else
#      echo "Writing disk image..."
#      dd if=/dev/zero of="${PRIDR}" bs=1M count="$(echo "${FRMTO}" | cut -b 2-)" status=progess
#    fi
#  fi
#  echo "Creating partition table..."
#  printf "i\n" | sudo parted "${PRIDR}" mklabel msdos
#  case $(echo "${FRMTO}" | cut -b 1) in
#    n) PSTRT=1s ;;
#    m) PSTRT=8s ;;
#    g) PSTRT=64s ;;
#    o) PSTRT=1MiB ;;
#  esac
#  printf "i\ni\n" | sudo parted -a none "${PRIDR}" mkpart primary ext4 "${PSTRT}" -- -1s
#  [ -b "${PRIDR}" ] && parted "$(echo "${PRIDR}" | cut -b 1-8)" name "$(echo "${PRIDR}" | cut -b 9-)"
#  LOOPD="$(sudo losetup -fP --show "${PRIDR}")"
#  echo "Creating file system..."
#  mkfs -q -t ext4 "${LOOPD}p1"
#  mkdir -p /mnt/crl
#  mount "${LOOPD}p1" /mnt/crl
#  echo "Creating swap file..."
#  dd if=/dev/zero of=/mnt/crl/swapfile bs=1M count="${RAMSZ}" status=progress
#  echo "Cleaning up..."
#  umount /mnt/crl
#  losetup -d "${LOOPD}"
#  exit 0
#fi

if [ "${FRMWR}" = "UEFI" ]; then
  UEFI="$(find /usr -type f -name 'OVMF_CODE.fd' | grep '64')"
  case "${UEFI}" in
    *OVMF_CODE.fd) UEFI="-bios ${UEFI}" ;;
    *) echo 'OVMF_CODE.fd not found' && exit 1 ;;
  esac
fi

BTPRM="-boot c"
[ -n "${BTISO}" ] && BTPRM="-boot d"
[ -n "${BTISO}" ] && [ -n "${SCNDR}" -o -n "${VIODR}" ] && BTPRM="-boot e"
[ -n "${FDIMG}" ] && BTPRM="-boot a"

LCV=0
for DRIVE in "${FDIMG}" "${PRIDR}" "${SCNDR}" "${VIODR}" "${BTISO}" "${DRISO}"; do
  LCV=$((LCV+1))
  if [ -n "${DRIVE}" ]; then
    case ${LCV} in
      1) DRVID="fd0"; MTYPE="floppy"; DRVIF="floppy"; IFSLT="bus=0,unit=0";;
      2) DRVID="hd0"; MTYPE="disk"; DRVIF="${IFACE}"; [ "${IFACE}" = "ide" ] && IFSLT="bus=0,unit=0" || IFSLT="";;
      3) DRVID="hd1"; MTYPE="disk"; DRVIF="${IFACE}"; [ "${IFACE}" = "ide" ] && IFSLT="bus=0,unit=1" || IFSLT="";;
      4) DRVID="vd1"; MTYPE="disk"; DRVIF="${IFACE}"; [ "${IFACE}" = "ide" ] && IFSLT="bus=0,unit=1" || IFSLT="";;
      5) DRVID="cd0"; MTYPE="cdrom"; DRVIF="${IFACE}"; [ "${IFACE}" = "ide" ] && IFSLT="bus=1,unit=0" || IFSLT=""; [ "${IFACE}" = "virtio" ] && DRVIF="scsi";;
      6) DRVID="cd1"; MTYPE="cdrom"; DRVIF="${IFACE}"; [ "${IFACE}" = "ide" ] && IFSLT="bus=1,unit=0" || IFSLT=""; [ "${IFACE}" = "virtio" ] && DRVIF="scsi";;
    esac

    SDRVS="${SDRVS} -drive id=${DRVID},media=${MTYPE},file=${DRIVE},cache=none,if=${DRVIF}"
    [ -n "${IFSLT}" ] && SDRVS="${SDRVS},${IFSLT}"
    echo "${DRIVE}" | grep -q '[\.img\|\.iso]$' > /dev/null && SDRVS="${SDRVS},format=raw"
    chown qemu ${DRIVE}
  fi
done

case "$(uname)" in
  Linux)
    ACCEL='-enable-kvm'
    MACHN="${MACHN},accel=kvm"
    VNCMD="vncviewer :${XPORT}"
    ;;
  Darwin)
    MACHN="${MACHN},accel=hvf"
    VNCMD="open vnc://localhost:59${XPORT}"
    ;;
esac

case "$((VCORS % 2))" in
  0) THRDS=2 ;;
  1) THRDS=1 ;;
esac

PCORS="$((VCORS / THRDS))"

if [ -n "${BTISO}" -o -n "${DRISO}" ] && [ "${IFACE}" = "virtio" ]; then
  VSCSI="-device virtio-scsi-pci,id=scsi0"
  [ -n "${BTISO}" ] && VSCSI="${VSCSI} -device scsi-cd,bus=scsi0.0,drive=cdrom0"
  [ -n "${DRISO}" ] && VSCSI="${VSCSI} -device scsi-cd,bus=scsi0.1,drive=cdrom1"
fi

if ${VLNCH}; then
  case "${DSPLY}" in
    *vnc*)
      sh -c "sleep 1; su -c \"DISPLAY=${DISPLAY} ${VNCMD}\" - ${SUDO_USER}" > /dev/null 2>&1 & ;;
#   *spice*)
#    command -v spicy > /dev/null 2>&1 && CMMND="spicy -h localhost -p 60${XPORT}"
#     command -v remote-viewer > /dev/null 2>&1 && CMMND="remote-viewer spice://localhost:60${XPORT}"
#     sh -c "sleep 1; su -c 'DISPLAY=${DISPLAY} ${CMMND} > /dev/null 2>&1' - ${SUDO_USER}" & ;;
  esac
else
  echo "VIDEO MODE: ${VIDEO}"
fi

TMPFL="$(mktemp)"

printf '\n>>> USE send_key TO SEND KEY COMBOS TO VM THAT THE HOST GRABS
>>> USE system_powerdown TO SEND ACPI POWER BUTTON SIGNAL TO VM
>>> USE quit TO TELL QEMU TO STOP IMMEDIATELY
>>> PRESS CTRL+C TO FORCE-QUIT QEMU\n\n' > "${TMPFL}"

QCMND="qemu-system-x86_64 -runas qemu ${ACCEL} ${UEFI} \
  -m ${RAMSZ} -machine ${MACHN} ${BASE} ${W2KHK} -cpu host,+topoext \
  -smp cores=${VCORS},sockets=1,cores=${PCORS},threads=${THRDS} \
  -monitor stdio -device ${VIDEO} -display ${DSPLY} \
  -nic user,model=${NTCRD}${PRTFW} \
  -device virtio-keyboard-pci \
  -device virtio-${MOUSE}-pci \
  -device virtio-balloon-pci ${SDRVS} ${VSCSI} ${BTPRM}"

if [ -n "${TRMNL}" ]; then
  set -x
  ${TRMNL} -e "${QCMND}" &
  sleep 2
else
  [ -t 1 ] && cat "${TMPFL}"
  eval "set -x; ${QCMND}"
fi
